"""
Base Strategy Class
Abstract base class for all trading strategies
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import pandas as pd


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    timestamp: datetime
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    instrument: str  # e.g., 'RELIANCE 2400 CE'
    entry_price: float
    quantity: int
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Optional[Dict] = None


@dataclass
class Position:
    """Open trading position"""
    entry_time: datetime
    instrument: str
    position_type: str  # 'LONG', 'SHORT'
    entry_price: float
    quantity: int
    stop_loss: float
    take_profit: float
    current_price: float = 0.0
    
    @property
    def unrealized_pnl(self) -> float:
        """Calculate unrealized P&L"""
        if self.position_type == 'LONG':
            return (self.current_price - self.entry_price) * self.quantity
        else:
            return (self.entry_price - self.current_price) * self.quantity
    
    @property
    def unrealized_pnl_pct(self) -> float:
        """Calculate unrealized P&L percentage"""
        if self.entry_price == 0:
            return 0.0
        if self.position_type == 'LONG':
            return ((self.current_price - self.entry_price) / self.entry_price) * 100
        else:
            return ((self.entry_price - self.current_price) / self.entry_price) * 100


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies
    """
    
    def __init__(self, params: Dict):
        """
        Initialize strategy with parameters
        
        Args:
            params: Strategy-specific parameters
        """
        self.params = params
        self.name = self.__class__.__name__
        self.positions = []
        self.closed_trades = []
        
    @abstractmethod
    def on_data(self, current_data: pd.DataFrame, historical_data: pd.DataFrame) -> Optional[Signal]:
        """
        Process new market data and generate signals
        
        Args:
            current_data: Current candle data
            historical_data: Historical data for calculations
            
        Returns:
            Signal object or None
        """
        pass
    
    @abstractmethod
    def calculate_position_size(self, price: float, capital: float) -> int:
        """
        Calculate position size based on available capital
        
        Args:
            price: Entry price
            capital: Available capital
            
        Returns:
            Number of shares/contracts to trade
        """
        pass
    
    @abstractmethod
    def should_exit(self, position: Position, current_price: float, current_time: datetime) -> bool:
        """
        Check if position should be exited
        
        Args:
            position: Current position
            current_price: Current market price
            current_time: Current timestamp
            
        Returns:
            True if should exit, False otherwise
        """
        pass
    
    def reset(self):
        """Reset strategy state"""
        self.positions = []
        self.closed_trades = []
    
    def get_open_positions(self) -> List[Position]:
        """Get all open positions"""
        return self.positions
    
    def get_closed_trades(self) -> List[Dict]:
        """Get all closed trades"""
        return self.closed_trades
